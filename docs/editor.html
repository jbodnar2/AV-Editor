<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="./favicon.ico" />
    <link rel="stylesheet" href="css/reset.css" />
    <link rel="stylesheet" href="css/main.css" />
    <title>AV Editor</title>
  </head>

  <body>
    <header>
      <div class="container">
        <h1>Editor</h1>
      </div>
    </header>
    <nav>
      <div class="container">
        <ul>
          <li><a href="./">Home</a></li>
          <li>
            <button
              id="clear-local-storage"
              onclick="clearLocalStorage()"
              style="cursor: pointer; height: 100%; background-color: inherit; border: none; color: white"
            >
              Undo Edits
            </button>
          </li>
          <script defer>
            function clearLocalStorage() {
              localStorage.clear();
              location.reload();
            }
          </script>
        </ul>
      </div>
    </nav>
    <main>
      <div class="container editor">
        <!-- Main content start -->

        <!-- Page title -->
        <h2 id="page-title">Video Title</h2>

        <div id="media-wrapper" class="media-wrapper">
          <!-- Media & Global Controls Content -->
        </div>

        <div id="editor-wrapper" class="editor-wrapper" data-show-end>
          <!-- Editor Content -->
        </div>

        <!-- Main content end -->
      </div>
    </main>

    <footer></footer>
    <!-- Scripts -->
    <script type="module" defer>
      import { getMediaItem, extractMediaItemIdFromUrl } from "./js/components/api.js";
      import { setLocalMediaItem } from "./js/components/store.js";
      import { addTrack } from "./js/components/tracks.js";
      import { addTranscript } from "./js/components/transcripts.js";
      import { renderMedia } from "./js/components/media-item.js";

      const pageTitle = document.querySelector("#page-title");
      const mediaWrapper = document.querySelector("#media-wrapper");
      const editorWrapper = document.querySelector("#editor-wrapper");

      function highlightCueSegment(event, video) {
        const activeCue = event.target.activeCues?.[0];

        if (!activeCue) return;

        const scrollTargetID = `cue-${activeCue.id}`;
        const scrollTarget = editorWrapper.querySelector(`#${scrollTargetID}`);

        const timeButton = scrollTarget?.querySelector(".cue-select-button");

        const isPlaying = video.paused;

        const previousCues = [...editorWrapper.querySelectorAll(".cue--focus")];

        previousCues.forEach(previousCue => {
          previousCue.classList.remove("cue--focus");
          previousCue.querySelector(".cue-select-button")?.classList.toggle("cue-select-button--playing", false);
        });

        scrollTarget?.classList.add("cue--focus");

        timeButton?.classList.toggle("cue-select-button--playing", isPlaying);

        scrollTarget?.scrollIntoView({ behavior: "smooth", block: "center" });
      }

      function setToTime(event, video) {
        const target = event.target.closest(".cue");

        if (!target) return;

        // NOTE: Adding a fraction of a second to the star time is done to handle Chrome / Firefox selection discrepancy,
        // cf. README.md note I
        let cueStartTime = parseFloat(target.dataset.startTime) + 0.00001;

        if (!cueStartTime) return;

        video.currentTime = parseFloat(cueStartTime);
      }

      function playPauseMedia(event, video, editorWrapper) {
        setToTime(event, video);

        const isPlaying = video.paused;
        editorWrapper.classList.toggle("is-playing", !isPlaying);

        if (!event.target.matches(".cue-play-button, .cue-pause-button")) return;

        isPlaying ? video.play() : video.pause();
      }

      function updatePlayState(event, video, editorWrapper) {
        const isPlaying = !video.paused;

        editorWrapper.classList.toggle("is-playing", isPlaying);
      }

      function updateLocalMediaItem(mediaItemId, mediaItem) {
        setLocalMediaItem(mediaItemId, mediaItem);
      }

      function showEditSuccessNotification(cueId, updatedText, previousText) {
        const notification = document.querySelector(`#cue-notification-${cueId}`);
        notification.textContent = "Edit saved 👍";
        notification.classList.add("cue-notification--success");

        setTimeout(() => {
          notification.textContent = "";
          notification.classList.remove("cue-notification--success");
        }, 2000);
      }

      function handleTextChange(event, media, video) {
        const cue = event.target.closest("[data-cue]");

        const cueId = cue && cue.dataset.cue;

        if (!cueId) {
          return;
        }

        const updatedText = event.target.value.trim();

        if (!updatedText) {
          return;
        }

        const mediaItemId = extractMediaItemIdFromUrl();

        if (!mediaItemId) {
          return;
        }

        getMediaItem(mediaItemId).then(mediaItem => {
          const transcript = mediaItem.transcript;
          const segment = transcript.segments[cueId];

          if (segment) {
            const previousText = segment.text.trim();

            segment.text = updatedText;

            if (!segment.edits) {
              segment.edits = [];
            }

            segment.edits.push(previousText);

            updateLocalMediaItem(mediaItemId, mediaItem);

            const track = video.textTracks[0];
            const activeCue = track.activeCues[0];

            if (activeCue) {
              activeCue.text = updatedText;
            }

            showEditSuccessNotification(cueId, updatedText, previousText);
          }
        });
      }

      // When DOM loaded, render the media, add listeners, and handle form submission
      document.addEventListener("DOMContentLoaded", () => {
        // Render the media and get the media data
        renderMedia(pageTitle, mediaWrapper).then(mediaData => {
          if (!mediaData) return;

          // Destructure the media data
          const { transcript, id: itemId, video, controls } = mediaData;

          // Add the track and get the track and cues
          const { track, cues } = addTrack(video, transcript);

          // Add the transcript form and get the form element
          const form = addTranscript({ track, cues, itemId, editorWrapper });

          // Add event listeners for the cue change
          track.addEventListener("cuechange", event => {
            highlightCueSegment(event, video);
          });

          // Add event listeners for the play and pause buttons
          editorWrapper.addEventListener("click", event => playPauseMedia(event, video, editorWrapper));

          // Add event listeners for the video events
          ["playing", "pause"].forEach(type => {
            video.addEventListener(type, event => updatePlayState(event, video, editorWrapper));
          });

          // Add event listeners to manage editing the transcript
          form.addEventListener("submit", event => event.preventDefault());
          form.addEventListener("change", event => {
            handleTextChange(event, mediaData, video);
          });

          controls.addEventListener("change", event => {
            if (!event.target.matches("#show-problems")) return;
            const isChecked = event.target.checked;

            editorWrapper.classList.toggle("show-problems", isChecked);
          });
        });
      });
    </script>
  </body>
</html>
